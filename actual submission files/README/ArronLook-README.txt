Name; Arron Look
RCS: LOOKA
Group 1
Members: Finnegan, Sebastian, Wilson, Arron

Here is how we split our roles for Homework 2:
Finnegan worked on the random number generator
Wilson worked on the jQuery UI Sliders
Sebastian worked on the scoreboard formulas and started the front end
Arron worked on the main $.fn.hexed( settings ) function and the way the plugin would handle the entire game.

NOTE: I essentially combined all their work into the required jQuery plugin format and edited their code so the game would run as specifed by the PDF.
NOTE: To use this plugin, please include the external style sheet called "team1-hw2.css", the script for jquery that we provided "jquery-1.4.3.min.js", and or plugin "team1-hw2.js" and be sure to have a script similar to $(SELECTOR).hexed(); Feel free to use our provided index.html instead though.

Just for clarification:
The $.fn.hexed plugin function is used to start/restart the game
The $.fn.defaults is used to contain the current game's data (difficulty, number of turns, etc.)
The $.fn.set_game_param is used to disable the form inputs
The restart function in $.fn.defaults is used to load in the elements for the entire game and to assign the event handling for the entire game
The set_options function is to change the values in $.fn.defaults based on player input

What I did:
The goal was to get the entire project to load from a single jQuery plugin in the end, so I decided that calling $("INSERT SELECTOR HERE").hexed( optional settings ) would generate the html for the entire game in that jQuery object and that the plugin would handle the entire game. We do have an external style sheet that I could have converted to JavaScript, but that might make it more confusing and harder to modify during developmental stages.
NOTE: To use this, do $("selector").hexed(); in a script tag. Everything should work from there since there is a button that will get generated that when clicked will provide the settings to $.fn.hexed(settings);.
I started by setting up the skeleton of the jQuery plugin we were supposed to make by introducing the $.fn.hexed( settings ) function inside an immediately invoked function expression to prevent conflicts where $ did not symbolize the jQuery library. From there I considered how to keep track of the number of turns left, how to prevent users from changing the difficulty during the middle of the game, how to handle situations where the user wanted to restart the game, and what to do at the end of the game.
The first task I had to deal with was how the user would input their desired difficulty and number of turns at the start of the game. I used the $.fn.hexed function initially with no if conditions to generate a form containing a drop down list and button pair as well as a number input and button pair in the body of the html page. The button accompanying each pair was my method of having the user confirm and commit their desired difficulty and desired number of turns. Both buttons had an onlick attribute that would call a JavaScript function that would disable the select or input tag as well as undisplay the corresponding button that was clicked so the user would have no way to change their commitment. Once that was settled, I moved onto how to store the difficulty and the number of turns so it would be tedious for the user to change during a game. From the "Advanced jQuery Plugin" page, I decided to make it a plugin default since it was easier to access the data in the console for debugging purposes that way compared to just defining a variable for the plugin. It was also better to do so since it would be easier for people who want to reuse this plugin to change the default values and functions. I then moved the code that inserted the form for difficulty and number of turns selection into a function stored in $.fn.default, the plugin defaults, since the "Advanced jQuery Plugin" page said that was the only way for "this" to refer to $.fn.default. I also added a submission button called "Start" that would call $.fn.hexed() with the appropriate settings in an object input that would start the game. The $.fn.hexed function would generate the page if the given jQuery object does not have the start button in it, reset the page content if the user chose to click the Restart button, start the game if the user confirmed both difficulty and the number of turns, or alert the user that they have not selected a difficulty or number of turns yet.
By this time, all group members have finished their parts so I started combining their code into the hw2.js that I was working on. After moving all the functions into the invoked function, I started to modify Finn's event handling for the "next" button so it would keep track of the number of turns left -- by decrementing the turns_left stored in $.fn.default.game_state -- and made an updating display on the turns left. I also made it so that the two circles that Finn made would start off with the same colors when the entire game is first loaded into the jQuery object. For Sebastian's scoreboard code, I had to include an if condition in Finn's event handling code for the "next" button so clicking that button would store a Date() object in $.fn.defaults.game_state.start_time so the time it takes for submitting an answer starts the moment the user clicks the "next" button. Moving Sebastian's code inside of Finn's event handling for the "next" button, I had to fix his little issue with mixing strings, numbers, and Date objects together -- that resulted in NaN until I figured out that the types were mixed. I also moved all of the html that my group and I made into one large string to pass into the jQuery html() in the "restart" function object. The html() function would act on the div tag we created called <div id="page-wrapper"> that we appended on the initial $.fn.hexed() call that loaded in the HTML elements. I also stored the jQuery object as $.fn.default.game_elem to make sure that we always work on the same element, expecially when we restart. At the end, I needed one more function object called set_options in order to set the difficulty and number of turns we stored in $.fn.default.game_state and to set the reamining number of turns stored in $.fn.default.game_state.turns_left. Note that $.fn.defaults.options stores the default values.
In summary: I started off making a form to get the difficulty and number of turns for the game with a submission button. I then made it so that javascript would generate those buttons and eventually moved it into the invoked function expression for our jQuery plugin. I then combined the entire group's work into the invoked function and modified/ linked all the code bits that each member worked on e.g. linking Finn's "next" button to be the event that handled submissions and would update the turns left and score. Afterwards, I made sure that the entire plugin would work regardless of the selector initially provided. In order to conform with the pdf, I had decided to reuse Finn's "next" button as a "check it" button using if conditions to handle both cases. I also reused the "start" button as a restart button and a new game button similarly. We all started by making JavaScript functions that used jQuery and html elements hard coded into our index.html and I ended up combining the bits of functional code that everyone worked on and decided how the difficulty and number of turns would be taken in and made it so that the jQuery Plugin would output the entire game into the specified selector.

Questions:
1) What are the advantages to writing a jQuery plugin over regular JavaScript that uses jQuery?
- Writing a jQuery plugin allows our code to be chained with other jQuery objects e.g. $("body").method(args).ourPluginFunction(args); which allows easy usage instead of having to somehow reference that object again after running a jQuery method on it since the JavaScript that uses jQuery method would not be able to be chained to a jQuery object. Even if we made a function that does everything for us in the regular JavaScript using jQuery method, it would provide too much abstraction making it hard to flexibly reuse the JavaScript file, whereas a jQuery plugin can easily be modified and reused. A jQuery plugin would have default settings somewhere in the file and can easily be modified to conform to other jQuery plugins and methods whereas the JavaScript file that uses jQuery method would be difficult to integrate with jQuery and its plugins due to lack of chaining and the myriad of functions it may take. So, jQuery plugins are essentially easy to customize/ repurpose, are compatible with other jQuery plugins and compatible with jQuery chaining, and provides a level of abstraction and containment that does not take away from its granularity compared to just making a regular JavaScript that uses jQuery. Also note that making a regular JavaScript that uses jQuery would take up too many function names in this case whereas jQuery plugins are allowed private functions that saves on the available function names left.

Would have been better if we had time to figure out how to properly structure the whole batch of elements we are generating and include the css in the jquery instead of having an external one.

2) Explain how your jQuery plugin adheres to best practices in JavaScript and jQuery development.
- Our jQuery plugin consists of two plugin functions and one plugin object. The object, $.fn.defaults contains an options object, a game_state object, and two function objects. The reason why I used $.fn.defaults was to help with debugging the the jQuery plugin. It allowed external access to the options object, which is where we stored the default options for difficulty and number of turns. It also allowed external access to the game_state object that contained the committed difficulty, number of turns, and the starting time for each turn. The two function objects, set_options and restart, are used by the jQuery plugin and could have been private functions, but I left them as function objects for the user so I could use "this" to refer to $.fn.defaults and access the game_state data, especially for the set_options function since I felt it was more intuitive to call $.fn.defaults.set_options -- which is the reason why it returns $.fn.defaults. Our jQuery plugin adheres to best practices in jQuery development since all functions, except for set_options, returns the original jQuery object, allowing for chaining with other jQuery methods. The plugin was also made with an attempt to limit the amount of public jQuery plugin functions to prevent the chance that our plugin functions would be overwritten by another jQuery plugin. There would have been no way to access the set_game_param if it was a private function, so I made it a callable plugin function under the assumption that the $.fn.hexed(settings) function only took in settings as an argument. If possible -- pdf specifications being the limiting factor, I would have liked to make the entire plugin inside $.fn.hexed(settings), but the lack of allowed arguments for that function and the fact that we needed all the elements in the game to be generated by the plugin made it impossible to handle what the set_game_param function does inside $.fn.hexed(settings). Besides that, we encapsulated the jQuery plugin in an invoked function expression to prevent conflicts where $ is not the alias for the jQuery library. As for best practices in JavaScript, I believe that providing a decent comments in our code, but not overbearing -- to prevent comment clutter -- and the creation of two private helper functions that were used quite a bit in the restart function object sufficed. It demonstrated our ability to comment our code and our ability to create functions when a certain functionality was required in more than one place.

3) Does anything prevent you from POSTing high scores to a server on a different domain? If so, what? If not, how would we go about it (written explanation/pseudocode is fine here)?
- The one thing preventing us from POSTing high scores to a server on a different domain is the Same Origin Policy. The Same Origin Policy essentially prevents one site of one origin from accessing the resources from another site on a different origin, origin meaning the site has the same protocol, port, and host as the other site. In this case, trying to POST high scores to a server on a different domain that is guaranteed to have a different host means that they are different origins in which the Same Origin Policy would prevent the other site from accessing the POST you just sent. There are work arounds to this, such as Cross Origin Resource Sharing and other methods that would not be POST anymore. There are also some exploits that bypass Same Origin Policy, but I am assuming that it is not within the scope of this course.


Sources:
http://learn.jquery.com/plugins/basic-plugin-creation/
https://learn.jquery.com/plugins/advanced-plugin-concepts/
https://www.w3schools.com/tags/tag_option.asp
https://www.w3schools.com/tags/tag_button.asp
https://www.w3schools.com/tags/tag_select.asp
http://www.mkyong.com/jquery/how-to-check-if-an-element-is-exists-in-jquery/
https://www.w3schools.com/cssref/css3_pr_text-shadow.asp
https://stackoverflow.com/questions/11423682/cross-domain-form-posting
https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy
https://www.itprotoday.com/web-development/javascript-same-origin-policy
https://en.wikipedia.org/wiki/Same-origin_policy

